syntax = "proto3";

package tzero.v1.payment;

import "tzero/v1/common/payment_method.proto";
import "tzero/v1/common/payment_receipt.proto";
import "tzero/v1/common/common.proto";
import "ivms101/v1/ivms/ivms101.proto";
import "google/protobuf/timestamp.proto";
import "buf/validate/validate.proto";

/**
 * This service must be implemented by the provider.
 *
 * All methods of this service must be idempotent, meaning they are safe to retry and multiple calls with the same parameters must not have additional effect.
 */
service ProviderService {

  /**
    * Network instructs the provider to execute a payout to the recipient.
    * This method should be idempotent, meaning that multiple calls with the same parameters will have no additional effect.
   */
  rpc PayOut(PayoutRequest) returns (PayoutResponse) {
    option idempotency_level = IDEMPOTENT;
  };

  /**
    * Network provides an update on the status of a payment. This can be either a success or a failure.
    * This method should be idempotent, meaning that multiple calls with the same parameters will have no additional effect.
   */
  rpc UpdatePayment(UpdatePaymentRequest) returns (UpdatePaymentResponse) {
    option idempotency_level = IDEMPOTENT;
  };

  /**
   * This rpc is used to notify the provider about the changes in credit limit and/or credit usage.
   */
  rpc UpdateLimit(UpdateLimitRequest) returns (UpdateLimitResponse) {
    option idempotency_level = IDEMPOTENT;
  };

  /**
    * Network can send all the updates about ledger entries of the provider's accounts. It can be used to
    * keep track of the provider's exposure to other participants and other important financial events. (see the list in the message below)
   */
  rpc AppendLedgerEntries(AppendLedgerEntriesRequest) returns (AppendLedgerEntriesResponse) {
    option idempotency_level = IDEMPOTENT;
  };
}

message AppendLedgerEntriesRequest {
  /**
    * This is a list of transactions that were appended to the ledger of the provider.
    * The transaction_id should be used to identify the transaction and ensure that it is processed only once.
   */
  repeated Transaction transactions = 20 [(buf.validate.field).repeated.min_items = 1];

  message Transaction {
    /**
      * transaction_id is an incrementally growing identifier for the transaction.
      * It could have gaps and could be out of order, but it is unique for each transaction.
     */
    uint64 transaction_id = 10 [(buf.validate.field).uint64.gt = 0];
    /**
      * entries is a list of ledger entries that were appended to the ledger of the provider.
      * Each entry represents a financial event that occurred in the provider's accounts.
      */
    repeated LedgerEntry entries = 30 [(buf.validate.field).repeated.min_items = 1];

    /**
     * transaction_details is a oneof field that contains details about the transaction.
     * It can be one of the following: PayIn, PayoutReservation, Payout, ProviderSettlement, FeeSettlement, PayoutReservationRelease.
     */
    oneof transaction_details {
      option (buf.validate.oneof).required = true;
      Payout payout = 130;
      ProviderSettlement provider_settlement = 140;
      FeeSettlement fee_settlement = 150;
    };

    message Payout {
      uint64 payment_id = 10 [(buf.validate.field).uint64.gt = 0];
    }

    message ProviderSettlement {
      uint64 settlement_id = 10 [(buf.validate.field).uint64.gt = 0];
    }

    message FeeSettlement {
      uint64 fee_settlement_id = 10 [(buf.validate.field).uint64.gt = 0];
    }
  }

  message LedgerEntry {
    /* 1 is network account, others are ids of participants */
    uint32 account_owner_id = 10;
    /**
     * account_type is the type of the account that the entry belongs to.
     * It is used to categorize the entries and understand the nature of the financial event.
     */
    AccountType account_type = 20;
    /**
     * debit is the amount that was debited from the account.
     * If the entry is a credit, this field should be 0.
     */
    tzero.v1.common.Decimal debit = 40;
    /**
     * credit is the amount that was credited to the account.
     * If the entry is a debit, this field should be 0.
     */
    tzero.v1.common.Decimal credit = 50;
  }
  
  enum AccountType {
    ACCOUNT_TYPE_UNSPECIFIED = 0;
    ACCOUNT_TYPE_BALANCE = 20;
    ACCOUNT_TYPE_PAY_IN = 40;
    ACCOUNT_TYPE_PAY_OUT = 50;
    ACCOUNT_TYPE_FEE_EXPENSE = 60; // Reflects the fees that the provider has to pay for the services provided by the network.
    ACCOUNT_TYPE_SETTLEMENT_IN = 80;
    ACCOUNT_TYPE_SETTLEMENT_OUT = 90;
  }
}

message AppendLedgerEntriesResponse {}

message PayoutRequest {
  /**
   * payment id assigned by the network (provider should store this id to provide details in UpdatePayout later)
   */
  uint64 payment_id = 10;
  /**
   * payout id assigned by the network (provider should store this id to provide details in UpdatePayout later)
   */
  uint64 payout_id = 20;
  /**
   * currency of the payout (participant could support multiple currencies)
   * This is the currency in which the payout should be made.
   */
  string currency = 30;
  /**
   * client quote id of the quote used for this payout (the provider provides the quote IDs in the UpdateQuote rpc)
   * This is the identifier of the quote that was used to calculate the payout amount.
   */
  string client_quote_id = 40;
  /**
   * amount in currency of the payout
   * This is the amount that should be paid out to the recipient.
   */
  tzero.v1.common.Decimal amount = 50;
  /**
   * payout_method is the payment method for the payout, e.g. bank transfer, crypto transfer, etc.
   * This is used to specify how the payout should be made.
   */

  optional tzero.v1.common.PaymentMethod payout_method = 60;

  /**
   * Pay-in provider id which initiated the pay out.
   */
  uint32 pay_in_provider_id = 80;


  optional TravelRuleData travel_rule_data = 200;

  message TravelRuleData {
    // the natural or legal person that requests payment with originating provider
    repeated ivms101.Person originator = 10 [(buf.validate.field).repeated.min_items = 1];

    // the natural or legal person or legal arrangement who is identified
    // by the originator as the receiver of the requested payment.
    repeated ivms101.Person beneficiary = 20 [(buf.validate.field).repeated.min_items = 1];

    optional ivms101.Person originator_provider = 30;
  }
}

message PayoutResponse {
  oneof result {
    /**
     * Success response - means the payout was executed successfully and the payment is now complete. This happens when
     * the payout is successfully processed by the payout provider, and the payment was made to the recipient.
     */
    Accepted accepted = 20;
    /**
     * Failure response - means the payout was not executed successfully, e.g. the payout provider could not process the payout.
     */
    Failed failed = 30;
  }

  message Accepted {
  }

  message Failed {
    Reason reason = 10;

    enum Reason {
      REASON_UNSPECIFIED = 0;
    }
  }
}

message UpdatePaymentRequest {
  /**
   * payment_id is a payment id in the T-0 network.
   */
  uint64 payment_id = 5;
  /**
   * payment_client_id is a payment id assigned by the client, this is the same id that was provided in the CreatePaymentRequest.
   */
  string payment_client_id = 10;

  oneof result {
    /**
     * Accepted response - means the payout was accepted by the pay-out provider and pay-out provider is obligated to
     * make a pay-out.
     */
    Accepted accepted = 20;

    /**
    * Payment failed and would not be retried.
     */
    Failed failed = 30;
    /**
     * Confirmed response - final state meaning the payout was executed successfully and the payment is now complete.
     * This happens when the payout is successfully processed by the payout provider, and the payment was made to the recipient.
     */
    Confirmed confirmed = 40;
  }

  message Accepted {
    tzero.v1.common.Decimal payout_amount = 10; // amount in currency of the payout

    optional TravelRuleData travel_rule_data = 20;

    message TravelRuleData {
      optional ivms101.Person beneficiary_provider = 10;
    }
  }

  message Failed {
    Reason reason = 10;

    enum Reason {
      REASON_UNSPECIFIED = 0;
    }
  }

  message Confirmed {
    google.protobuf.Timestamp paid_out_at = 10; // time of the payout

    /**
    * Payment receipt might contain metadata about payment recognizable by pay-in provider.
    */
    tzero.v1.common.PaymentReceipt receipt = 20;
  }

}
message UpdatePaymentResponse {}

/* All the amounts are in USD */
message UpdateLimitRequest {
  /**
   * can contain one or more Limit messages, each representing a credit limit for a specific counterparty provider.
   */
  repeated Limit limits = 10;

  message Limit {
    /**
       * Incrementally growing for the provider - same as in Ledger.
       */
    int64 version = 10;
    /**
     * the Id of the counterparty (creditor) provider, e.g. the provider that is providing the credit limit.
     * It's usually the payOut provider, which provides the credit line to the payIn provider.
     */
    int32 creditor_id = 15;
    /**
     * payout_limit = credit_limit - credit_usage, negative value means credit limit is exceeded,
     * e.g. if counterparty decreased credit limit
     */
    tzero.v1.common.Decimal payout_limit = 20;
    /**
     * This is the credit limit that the counterparty is willing to extend to the provider.
     */
    tzero.v1.common.Decimal credit_limit = 30;
    /**
     * This is the credit usage that the provider has used so far. It is the sum of all payouts made by the provider
     * minus the settlement net (settlement balance). It could be negative if the provider has received more
     * in settlements than made payouts (pre-settlement).
     */
    tzero.v1.common.Decimal credit_usage = 40;
  }
}

/**
 * Empty message - means no response is needed.
 */
message UpdateLimitResponse {}
